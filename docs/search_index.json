[
["index.html", "FIP 606 Prefácio", " FIP 606 Prof. Emerson M. Del Ponte Prefácio Este material está sendo elaborado como texto fundamental da disciplina FIP606 - Análise e visualização de dados em Fitopatologia oferecida na Pós-graduação em Fitopatologia da Universidade Federal de Viçosa. A disciplina, reformulada no ano de 2018, objetiva: Capacitar os estudantes para conduzirem todas as etapas da pesquisa desde o planejamento da pesquisa, coleta, preparo e análise dos dados e comunicação dos resultados, no ambiente computacional R Todas as etapas são ensinadas no ambiente de desenvolvimento integrado (IDE) R Studio. A primeira versão desse material foi produzida em março de 2018 com fragmentos de textos e códigos em R Markdown produzidos nos três semestres anteriores desde que foi oferecida pela primeira vez em 2015. A apostila está sendo produzida em R Markdown que combina textos e códigos em R, utilizando o pacote de autoria de livros bookdown para a geração do livro no formato gitbook. A programação em R é ensinada no IDE RStudio e na filosofia do tidyverse. Embora a disciplina tenha como alvo estudantes de pós-graduação em Fitopatologia, os princípios e métodos de análise e visualização de dados aqui apresentados são comuns a outros áreas do conhecimento com tipos de dados e problemas similares. "],
["introducao.html", "Capítulo 1 Introdução 1.1 Estatística e computação 1.2 A pesquisa reproduzível 1.3 Boas práticas 1.4 Sugestão de leituras", " Capítulo 1 Introdução Um pesquisador necessita ter conhecimento sobre análise de dados (ou estatística) durante a sua formação. Ao longo de sua vida profissional, deve continuar se atualizando sobre as tendências e novas ferramentas da metodologia científica, especialmente se o trabalho envolve experimentos ou levantamentos de dados. Além de ter que saber como escrever um artigo científico, ou outro produto da pesquisa como um relatório técnico para agência de fomento ou comunicação em evento, o pesquisador tem na estatística o suporte às conclusões de um trabalho. A publicação científica na forma de um artigo em revista com corpo editorial é um dos principais e mais valorizados produtos da pesquisa. Um pesquisador é considerado produtivo com base no número de artigos publicados, associado à qualidade dos trabalhos com base em inúmeras métricas, tais como fator de impacto da revista, número de citações do trabalho e o índice H do pesquisador. Para se ter um bom artigo científico deve-se utilizar os métodos apropriados para o planejamento da pesquisa e da coleta, preparo e a análise dos dados, dos quais dependerão os resultados. Não raro os estudantes concentrarem a maior parte do tempo na condução do trabalho (bancada ou campo) e relativamente pouco em revisão bibliográfica, leitura crítica, redação científica e análise e visualização dos dados. Essas atividades são tão ou mais importantes do que a condução do trabalho, principalmente se o mesmo almeja uma carreira na academia. São raros os estudantes que, durante a pós-graduação, cursam disciplinas de metodologia científica ou de análise de dados aplicada às situações reais e operacionais do a dia do pesquisador - o mais comum é cursar um disciplina de estatística que tem um enfoque mais teórico 1.1 Estatística e computação Na área de ciências biológicas e agrárias é muito comum os trabalhos acadêmicos serem baseados em uma pesquisa observacional ou experimental, ou a combinação de ambas, a qual é baseada em evidências, os dados da pesquisa. Assim, saber como planejar as etapas da pesquisa, especialmente a forma de obtenção, preparo e análise estatística dos dados, é fundamental para o sucesso da mesma. O estudante deve ter um conhecimento mínimo necessário para conduzir o seu trabalho e, idealmente, aprender a conduzir a análise de maneira independente ou bem assessorado. Para isso, depende-se dos programas computacionais. Quando há alguma dificuldade, ou mesmo para que tem facilidade em utilizar programas estatísticos, é desejável consultar um estatístico ou pesquisador da área, se não o orientador, que tenha bom domínio de métodos quantitativos para orientar sobre a análise mais apropriadas. Importante lembra que isso deve ser feito antes da condução do experimento! Um fato muito comum e que leva a erros que são propagados pelos pesquisadores é negligenciar a estatística e lembrar dela apenas quando da definição de um teste de hipótese. Para se ter noção do quanto a estatística é negligenciada em trabalhos de pesquisa, basta observar quantas linhas são dedicadas à descrição da análise de dados na seção de metodologia em artigos científicos. Poucos trabalhos mencionam detalhes ou justificam as decisões que foram tomadas no processo de análise. Apenas citar o teste utilizado e o programa computacional é colocar algo de extrema importância para a validade das conclusões em um segundo plano. A análise estatística é usualmente conduzida em um ambiente computacional de familiaridade do pesquisador ou de alguém que o auxilia na condução da pesquisa. Comumente, todo o processo é conduzido em diversos programas que executam tarefas diferentes. Por exemplo: Planilha eletrônica para organizar os dados Planilha ou programa de estatística para análise exploratória Um programa geral ou específico para realizar os procedimentos ou testes estatísticos Um programa para gerar os gráficos para publicação Um pesquisador que objetiva que sua pesquisa seja reproduzida terá dificuldade em documentar todos os passos de uma análise que utiliza vários programas e, em sua maioria, com programas de movimento de mouse (clique em menus). O problema é resolvido quando se utiliza um ambiente computacional que permita conduzir essas etapas. Não são muitas opções que existem nesse sentido. A minha de preferência é o ambiente computacional e estatístico R que tem, no ambiente de desenvolvimento integrado RStudio, uma excelente opção para trabalhar com tudo que o pesquisador precisa para conduzir as análises, bem como produzir relatórios de análise que integram textos e códigos interpretáveis. Nesta disciplina, o estudante aprenderá sobre boas práticas da análise de dados em sua rotina de trabalho. Com hábitos simples, persistência, sistemática e dedicação em um ambiente computacional como o R, o pesquisador moderno estará adotando práticas que, além de poder melhorar a qualidade e confiabilidade nos resultados da análise, que contribua para a maior transparência da ciência. Dentre os ambientes de programação disponíveis, as ferramentas mais usadas para implementar uma pesquisa reproduzível de maneira efetiva (dados, análises e saídas são combinados, idealmente, em um único ambiente de programação), são baseados em duas linguagens principais: Python e R, cujos produtos principais são Jupyter Notebooks e RMarkdown, respectivamente. Esses pacotes ou rotinas facilitam sobremaneira a documentação e reprodução das análises bem como aceleram a obtenção dos resultados e visualizações assim que novos dados forem adicionados ou reanálises são necessárias. Além de aprender a utilizar esses programas, é importante que o pesquisador aprenda a usar efetivamente planilhas eletrônicas para reunir e organizar os dados que serão usados na pesquisa. Por princípio, as planilhas eletrônicas como Excel, Libre Office Calc, Numbers e Google Sheets são usadas apenas para armazenar os dados e não para processar, transformar, visualizar ou fazer sumários prévios. O motivo é muito simples: esses procedimentos todos feitos com movimentos de mouse não são reproduzíveis! além disso, na pesquisa reproduzível os dados originais obtidos pelo pesquisador ou recebidos/coletados de outras fontes devem ser mantidos na sua forma original. Caso seja modificado de forma que é mais fácil fazer em uma planilha como renomear variáveis, é importante manter sempre uma planilha original como referência. 1.2 A pesquisa reproduzível A reprodutibilidade em ciência é um tema que tem despertado a atenção de pesquisadores, agências de fomento e a mídia acadêmica nos últimos anos. São frequentes os relatos de que um estudo que foi repetido gerou resultados diferentes ou mesmo discordantes de um estudo anterior. Os próprios pesquisadores tem se manifestado com grande preocupação com uma alegada “crise de reprodutibilidade” na ciência. As possíveis causas e algumas soluções para minimizar o problema vem sendo discutidas e algumas ações implementadas. É importante que o estudante e o pesquisador em geral tenham conhecimento sobre a correta definição dos termos para melhorar a comunicação. Reprodutibilidade tem diferentes significados dependendo do contexto. Aqui, definimos como: Pesquisa reproduzível é aquela em que um pesquisador consegue obter o mesmo resultado de um estudo prévio usando os mesmos materiais (dados) e métodos (estatística) da pesquisa original. Portanto, é necessário que o pesquisador que deseja reproduzir um estudo tenha 1) acesso aos dados e 2) saiba os detalhes de como a análise foi feita Os resultados discordantes, ou inconsistentes, em diferentes estudos se refere, na verdade, à replicabilidade, ou a reprodutibilidade inferencial, segundo alguns autores. Em ciência, parte-se do princípio que os resultados de uma pesquisa publicados em revistas com corpo editorial tenham sido obtidos segundo os princípios que regem os métodos e a ética científica. No entanto, os editores e revisores, quase sempre, não tem como verificar se todos os passos do trabalho, especialmente a análise dos dados, foram executados corretamente, uma vez que avaliam apenas o artigo científico e, raramente, algum material suplementar quando esse está disponível. Um artigo científico é escrito e submetido para publicação segundo convenções da academia que definem o conteúdo mínimo para que o trabalho seja avaliado pelos pares. Normalmente esse conteúdo consiste no texto, gráficos e tabelas e, idealmente, um material suplementar. Organizar todo esse material de forma sistemática exige tempo do pesquisador, o que acaba desencorajando muitos pesquisadores que não adotam rotinas de boas práticas da pesquisa reproduzível. É nesse contexto que entram rotinas de programação em ambientes computacionais. Segundo Yihui Xie, um dos principais desenvolvedores do R da empresa RStudio de programas (ex. knitr, rMarkdown, bookdown, etc) que visam facilitar a pesquisa reproduzível: O produto final da pesquisa não é somente o artigo científico, mas tambémm o ambiente computacional completo utilizado para produzir os resultados no artigo como os códigos e os dados necessários para a reprodução dos resultados e avanço da pesquisa (Xie et al. 2014). 1.3 Boas práticas Para um estudante ou cientista que está iniciando um projeto é importante que as boas práticas da pesquisa reproduzível sejam incorporadas no seu dia a dia, e que sejam implementadas desde a concepção e o planejamento do mesmo. São atividades que dependem essencialmente de capacidade organizacional e planejamento do tempo e documentação das etapas do processo. É preciso seguir rotinas e gerar documentos que seguem certas normas de padronização, especialmente se o trabalho é feito de forma colaborativa. Analogamente, é como escrever e formatar um artigo científico que deve ser estruturado e apresentado segundo determinadas normas. Aqui, o produto gerado não é somente o documento do manuscrito e um punhado de gráficos, mas sim tudo que foi gerado durante a pesquisa, e que precisa estar bem organizado e formatado para uso posterior e publicação/divulgação. Para obter sucesso na pesquisa, é preciso: Ser diligente e sistemático Aprender novas ferramentas (computacionais) Aprender a organizar arquivos diversos Documentar todas as etapas do trabalho No dia a dia, os pesquisadores não sobrevivem sem os computadores como ferramenta central de trabalho. Atualmente, não é preciso ser um “nerd” para que se possa utilizar com bastante eficiência os computadores para ser eficiente e produtivo no trabalho. Em algumas áreas da pesquisa é necessário maior envolvimento com linguagens de programação ou programas específicos que exigem um maior esforço de aprendizado da lógica da programação. No entanto, o mais importante e desafiador é certamente aprender a sistemática de trabalho do que ser um expert em programação - mas é necessário sim aprender o básico de uma linguagem de programação (R ou Python) para implementar as boas práticas. Durante nossa formação acadêmica não recebemos nenhum ou muito pouco treinamento em como preparar e organizar de maneira apropriadas os arquivos diversos incluindo dados, códigos, gráficos, tabelas, manuscrito, figuras, etc. Apender uma rotina de análise de dados é fundamental para a) facilitar o nosso próprio trabalho de análise-reanálise; b) permitir o uso dos dados e códigos por colaboradores e c) documentar a análise, ou seja, explicar o que, por que e como foi feito. Quando não somos treinados a trabalhar dessa maneira é muito comum: criarmos um número grande arquivos e versões desnecessárias que dificultam o processo; gerarmos inconsistência e redundância nas análises; não termos um controle adequado de versões e dificuldade quando é solicitado o compartilhamento do trabalhos; levarmos um tempo longo para organizar o trabalho que só o próprio pesquisador entende (quando entende!). Práticas que deveriam ser simples como refazer um gráfico ou estatísticas, após receber os pareceres de revisores, se tornam um verdadeiro pesadelo para alguns pesquisadores, o que contribui para o atraso na publicação de artigos. 1.4 Sugestão de leituras Esta seção estará sendo atualizada a cada semestre com sugestões de leituras no tema pesquisa reproduzível utilizando o ambiente R. Primeiros passos no R/RStudio - Using Projects Textos e tutoriais - R for data science - Data Analysis and Visualization in R for Ecologists "],
["carregando-os-dados-no-ambiente.html", "Capítulo 2 Carregando os dados no ambiente 2.1 Usando o argumento text 2.2 Importando do excel 2.3 Dados em outros arquivos 2.4 Dados em pacotes 2.5 Dados de pacotes 2.6 Referências na web", " Capítulo 2 Carregando os dados no ambiente Como rotina em uma análise de dados, um dos primeiros passos é criar, carregar ou importar o conjunto de dados no ambiente R. O formato mais comumente utilizado para o armazenamento de dados em várias colunas é o de data frame. Existem várias maneiras de se carregar os dados e criar data frames, dependendo do tamanho do conjunto e formato disponível. Muitas vezes, queremos apenas criar conjuntos de sequencias ou números, que pode ser feito com as funções básicas que já foram vistas, não necessitando carregar arquivo externo. Comumente, os dados são organizados em planilhas eletrônicas, as quais devem ser importadas para o ambiente. Na sequencia, serão apresentadas as formas mais comuns de ter os dados no R para análise. 2.1 Usando o argumento text Uma forma de carregar rapidamente dados no ambiente é por meio do argumento text. Você pode copiar (ctrl + c) os dados de uma planilha e colar (ctrl + v) conforme o exemplo abaixo, entre aspas, após o argumento text da função read.table. Cada coluna será definida uma vez que tenha espaço entre os elementos. Pode ser útil para criar conjuntos pequenos. Abaixo, um exemplo de criação do conjunto survey. survey &lt;- read.table(h=T, text=&quot; campo ano severidade 25 2010 3 25 2010 4 25 2010 10 25 2010 23 25 2010 34 26 2010 2 26 2010 4 26 2010 5 &quot;) Verificar a estrutura do conjunto criado com a função str. str(survey) 2.2 Importando do excel Normalmente conjuntos de dados maiores são criados em planilhas eletrônicas e salvos em extensões do excel como xls ou xlsx. Há alguns pacotes que permitem importar arquivos do excel. Dentre as várias funções, destaca-se a read_excel do pacote readxl. ??readxl Vamos importar o arquivo fungicidewheat.xlsx e atribuir ao data frame wheat. Lembrando que deve-se incluir o caminho do arquivo, caso ele não se encontre no mesmo diretório onde está salvo o arquivo .r ou .rmd. library(readxl) # carrega o pacote no ambiente wheat &lt;- read_excel(&quot;data/fungicidewheat.xlsx&quot;) # leitura com a função read_excel head (wheat)[ ,1:4] # mostra apenas as 4 primeiras colunas ## # A tibble: 6 x 4 ## treat time dose rep ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ionic liquid Curative 0.5 1 ## 2 Ionic liquid Curative 0.5 2 ## 3 Ionic liquid Curative 0.5 3 ## 4 Ionic liquid Curative 0.5 4 ## 5 Ionic liquid Curative 0.5 5 ## 6 Ionic liquid Curative 2 1 2.3 Dados em outros arquivos Muitos arquivos de dados estão disponíveis em formatos csv (comma separated values) ou txt (texto). Esses arquivos também podem ser salvos nesse formato, a partir de uma planilha eletrônica. Vamos utilizar a função read_csv do pacote readr. Saber mais sobre o readr library(readr) # carrega o pacote wheat2 &lt;- read_csv(&quot;data/fungicidewheat.csv&quot;) # importa o arquivo csv ## Parsed with column specification: ## cols( ## treat = col_character(), ## time = col_character(), ## dose = col_double(), ## rep = col_double(), ## total_spikes = col_double(), ## dis_spikes = col_double(), ## total_spikelets = col_double(), ## dis_spikelets = col_double(), ## total_seeds = col_double(), ## inf_seeds = col_double() ## ) 2.4 Dados em pacotes O R vem com muitos arquivos de dados que são carregados quando da inicialização do programa, bastando apenas entrar com o nome do arquivo ou atribuir os dados a um dataframe. A função data() mostra todos os arquivos de dados com uma breve descrição. Entre com o nome do arquivo para visualizá-lo. Vamos carregar o conjunto de dados Orange. Note que entrando com o nome do conjunto os dados ele não carrega no “Environment”, mas apenas é mostrado. Veja a diferença abaixo. head(Orange) # apenas 6 primeiras linhas ## Tree age circumference ## 1 1 118 30 ## 2 1 484 58 ## 3 1 664 87 ## 4 1 1004 115 ## 5 1 1231 120 ## 6 1 1372 142 data(Orange) Pode-se atribuir o conjunto Orange a um determinado vetor. Vamos atribuir os dados na forma de um data fame com o nome laranja, assim ele ficará armazenado no ambiente. laranja &lt;- data.frame(Orange) # usa o comando data.frame head(laranja) ## Tree age circumference ## 1 1 118 30 ## 2 1 484 58 ## 3 1 664 87 ## 4 1 1004 115 ## 5 1 1231 120 ## 6 1 1372 142 2.5 Dados de pacotes Pacotes do R geralmente possuem arquivos de dados para demonstrar o uso das funções. Vamos carregar o pacote agricolae e visualizar o conjunto de dados com o nome ralstonia. library(agricolae) data(ralstonia) # o conjunto ralstonia foi carregado no ambiente 2.6 Referências na web [DataCamp tutorial] (https://www.datacamp.com/community/tutorials/r-data-import-tutorial) "],
["visualizacao-de-dados.html", "Capítulo 3 Visualização de dados 3.1 Dados de levantamento 3.2 Construindo um gráfico 3.3 Dados categóricos 3.4 Dados contínuos 3.5 Contínuos x categóricos 3.6 Duas variáveis contínuas", " Capítulo 3 Visualização de dados Na análise de dados, a visualização é uma etapa fundamental que permite ao pesquisador aprender sobre o conjunto de dados. A observação de dados em tabela não é muito informativa e pouco se pode aprender acerca de padrões, tendências e associações entre variáveis. É “enxergando” os dados que o pesquisador vai decidir sobre a necessidade de transformar, criar novas variáveis, e definir os modelos estatísticos a serem usados para testar as hipóteses. A visualização por meio de gráficos deve ser iniciada na fase de exploração e sumarização dos dados embora, de maneira geral, a idéia geral é que os gráficos são apenas necessários na etapa de comunicação dos resultados. São dois contextos diferentes em que se usam os procedimentos gráficos. Na etapa de visualização, o gráfico deve ser feito rapidamente e de maneira simples, utilizando tipos de gráficos apropriados para responder a uma determinada pergunta. O gráfico serve apenas para dar o subsídio necessário ao pesquisador para as decisões posteriores. Não é necessário que os gráficos sejam muito elaborados, com muitos detalhes (com títulos de eixos, legendas, etc.). Eles estão longe de serem os gráficos que serão apresentados em um publicação. Esses últimos exigirão um bom tempo do pesquisador para elaborar um bom gráfico para uma comunicação efetiva. Voltaremos nesse assunto mais para frente no capítulo sobre comunicação dos resultados. Neste capítulo, os dados servão visualizados no R utilizando-se o pacote ggplot2 que é considerado o “estado da arte” em visualização de dados no R ver página do ggplot2. Tradicionalmente, gráficos em R são elaboradores com funções do pacote Graphics que é nativo do R base, o qual foi desenvolvido e mantido pelo “R Core Team” e colaboradores ao redor do mundo. As funções de gráficos do R base tem uma sintaxe diferente do ggplot2 e não serão abordados nesse capítulo. 3.1 Dados de levantamento A partir de agora, iremos visualizar os dados do levantamento e identificação de isolados de fungos do complexo de espécie Fusarium gramineraum obtidos de lavouras de trigo do sul do Brasil Del Ponte et al., 2015 que trabalhamos nos capítulos anteriores. O conjunto já está em formato “arrumado”(tradução para “tidy”) onde cada linha do data frame é um isolado e cada coluna é uma variável, no caso um metadado associado com cada isolado. Na sequencia, vamos carregar esse conjunto de dados e selecionar apenas os isolados obtidos no Estado do Rio Grande do Sul por meio da função filter do pacote dplyr e atribuir ao data frame survey_rs. Após carregar os dados, é importante observar todas as variáveis do conjunto, o que nos dará ideia das perguntas acerca do conjunto de dados que serão feitas durante a visualização e assim elaborar as hipóteses a serem verificadas. library(readr) survey2 &lt;- read_csv (&quot;data/survey2.csv&quot;) library(dplyr) survey_rs &lt;- filter(survey2, state == &quot;RS&quot;) 3.2 Construindo um gráfico Um gráfico ggplot2 é feito com pelo menos duas funções. A primeira, ggplot, permite criar um sistema de coordenada do gráfico. Nela, o primeiro argumento esperado (o que vai entre parênteses) é o nome do conjunto de dados. Ao executar a função ggplot note que aparecerá um gráfico “vazio” para o conjunto survey_rs. library(ggplot2) ggplot(survey_rs) Na sequencia, deve ser informado um tipo de objeto geométrico (“geoms”) na forma de uma camada (layer) no gráfico. No contexto do conjunto de dados de trabalho, vamos responder à seguinte pergunta: O número de isolados em amostrados foi igual em cada um dos anos do levantamento? (lembrando que ano é uma variável categórica). 3.3 Dados categóricos No ggplot2 após entrar com a função ggplot, novas funções são adicionadas após o sinal positivo (+). O “geom” que iremos usar é o geom_bar, indicado para representar o número total de observações geral ou segundo alguma condição - um outra variável categórica. Seguindo com a construção de nosso gráfico no ggplot2 com dados condicionados por categorias de uma variável (no caso os níveis da variável “year”), essas são infomadas no atributo de estética aes que pode ser informado tanto na função ggplot ou na função geom_bar. O primeiro caso é a forma mais utilizada já que condiciona toda as outras camadas que poderão ser adicionadas no gráfico. Na função geom_bar, como padrão, os dados apresentados são o somatório do número de linhas (isolados) em cada ano. Veja abaixo as duas formas de obter o mesmo resultado. ggplot(survey_rs, aes(year))+ geom_bar(color = &quot;black&quot;, fill = &quot;blue&quot;)+ theme_light() Podemos ampliar a pergunta sobre quantos isolados em cada ano e em cada campo com determinado resto cultural. Assim, teremos duas informações apresentadas no gráfico o que exigirá uma legenda para auxilizar na interpretação. No ggplot2, a legenda é colocada automaticamente após definir o atributo fill. As cores são definidas automaticamente, sempre em uma mesma ordem, iniciando pelo vermelho, verde, azul, etc. library(ggthemes) survey_rs %&gt;% filter(residue != &quot;potato&quot;) %&gt;% ggplot(aes(year, fill=residue))+ geom_bar(position = &quot;dodge&quot;)+ theme_few()+ theme(legend.position = &quot;right&quot;)+ #scale_fill_manual(values = c(&quot;blue&quot;, &quot;yellow&quot;))+ labs(title = &quot;Titulo do gráfico&quot;, x = &quot;Ano&quot;, y = &quot;Frequencia&quot;, fill = &quot;Residue&quot;) Podemos modificar a posição das categorias com os atributos “stack”, “dodge” e “fill”. O padrão do geom_bar é a posição “stack” ggplot(survey_rs, aes(x= year, fill = species))+ geom_bar() ggplot(survey_rs, aes(x= year, fill = species))+ geom_bar(position = &quot;dodge&quot;) ggplot(survey_rs, aes(x= year, fill = species))+ geom_bar(position = &quot;fill&quot;) Podemos modificar o sistema de coordenadas para mostrar o número de isolados por espécies em um sistema polar. ggplot(survey_rs, aes(x= factor(year), fill = species))+ geom_bar()+ coord_polar() Alternativamente, similar a um gráfico de torta ou pizza ggplot(survey_rs, aes(x= factor(year), fill = species), width = 1)+ geom_bar()+ coord_polar(theta = &quot;y&quot;) Exercício Com base no que foi exposto, elabore gráficos de barras para outras variáveis categóricas respondendo às seguintes perguntas: O número de isolados foi diferente em campos de trigo com resíduos de soja e milho? Qual a espécie encontrada em maior frequencia no geral e em cada ano? Quais os cinco municípios que contribuiram com maior número de isolados? Qual a espécie encontrada em maior frequencia? Houve variação dessa frequencia entre os anos? 3.4 Dados contínuos Para dados contínuos, normalmente utilizamos histogramas, dotplots ou boxplots para descrever uma variável contínua isoladamente com outra contínua ou mesmo uma contínua com outra categórica. Gráficos de dispersão de pontos são usados para relacionar duas variáveis contínuas. No nosso conjunto, podemos perguntar sobre a origem dos isolados. Antes disso, vamos verificar primeiro se há mais um isolado amostrado em cada ponto (campo) usando a função table que irá sumarizar o número de entradas por campo. Vamos colocar os dados no formato de uma data.frame e listar apenas os seis primeiros registros. head(data.frame(table(survey_rs$field))) ## Var1 Freq ## 1 1 9 ## 2 2 9 ## 3 3 6 ## 4 4 11 ## 5 5 12 ## 6 6 8 Nota-se que temos campos que contribuiram com mais de um isolado. Então, para que não tenhamos múltiplos pontos em cada local, iremos selecionar apenas uma observação de cada campo combinando a função unique com a função select e atribuir essa seleção ao conjunto field_rs. field_rs &lt;- unique(select(survey_rs, c(1:6, 7:9))) field_rs$year &lt;- as.factor(field_rs$year) # vamos transformar year que é um variável numérica para factor Agora, podemos fazer um gráfico da relação entre latitude e longitude (duas variáveis contínuas) que permitirá visualizar a localização geográfica dos campos amostrados. ggplot(field_rs, aes(long, lat))+ geom_point() No gráfico acima, os pontos representam os três anos da amostragem. Podemos usar diferentes marcadores que identificam os diferentes anos. ggplot(field_rs, aes(long, lat, shape=factor(year)))+ geom_point() Para faciliar ainda mais a identificação dos pontos, podemos usar cores. ggplot(field_rs, aes(long, lat, shape = factor(year), color = factor(year)))+ geom_point(size=3) # aumentamos um pouco o tamanho do símbolo! Ou então, podemos utilizar a função facet_wrap para criar três gráficos condicionando pelo ano. ggplot(field_rs, aes(long, lat))+ geom_point(size=3)+ facet_wrap(~year, ncol=1) Uma outra pergunta que poderia ser feita, considerando variáveis contínuas, é sobre a distribuição dos valores de incidência e severidade nos campos visitados. Nesse caso, podemos usar histrogramas. No ggplot2, usamos a função geom_histogram para gerar um histograma da distribuição dos valores de severidade e de incidência. Note que o número de “bins” (categorias) é definido automaticamente. field_rs %&gt;% filter(residue != &quot;potato&quot;) %&gt;% ggplot(aes(factor(year), sev))+ geom_boxplot()+ geom_jitter(width=0.2, height=0, alpha=0.4)+ theme_grey()+ facet_wrap(~residue)+ ylim(0,25)+ ggsave(&quot;box1.png&quot;, width=6, height=3) ggplot(field_rs, aes(x= sev))+ geom_freqpoly() # vamos alterar o número de bins ggplot(field_rs, aes(x= inc))+ geom_histogram(bins = 10) O histograma é um ótima maneira de mostrar a simetria/assimetria da distribuição. Por exemplo, no caso da severidade, é evidente que há um concentração muito maior de valores abaixo de 2.5% e alguns poucos valores acima de 5%. Podemos visualizar os mesmos dados sob uma outra perspectiva, que é através do uso de boxplots com a função geom_boxplot. Veja explicação sobre boxplot. ggplot(field_rs, aes(x = field, y = inc))+ # usamos aqui uma variável contínua no x para um histograma para incidência geom_boxplot() ggplot(field_rs, aes(x = inc, y = sev))+ geom_boxplot()+ facet_wrap(~year) Outras formas de visualizar dados contínuos podem ser feitas com os seguintes geoms. geom_area geom_density geom_dotplot geom_freqpoly ggplot(field_rs, aes(sev))+ geom_dotplot(method = &quot;histodot&quot;, dotsize=0.75) ggplot(field_rs, aes(inc), fill = year)+ geom_dotplot(method = &quot;histodot&quot;, dotsize=1) 3.5 Contínuos x categóricos Podemos fazer boxplots para variáveis contínuas condicionadas por variáveis categóricas. Podemos responder a pergunta sobre a existência de variação de severidade entre os anos amostrados, por exemplo. O boxplot mostra na linha no centro da caixa a mediana e os valores discrepantes (outliers) que são os pontos acima da linha vertical. ggplot(field_rs, aes(year, sev))+ geom_boxplot() Uma outra forma é mostrar todas as observações de severidade de cada campo em cada ano. ggplot(field_rs, aes(year, sev))+ geom_point() Nesse caso acima, note que os pontos com valor iguais ou muito próximos ficaram sobrepostos o que dificulta a visualização do número de pontos. Podemos utilizar a função geom_jitter para adicionar um ruído aleatório nos dados que permitirá a visualização dos pontos que estão “escondidos”. ggplot(field_rs, aes(year, sev))+ geom_jitter() # podemos diminuir um pouco o ruído e mudar o símbolo e adicionar uma transparência ggplot(field_rs, aes(year, sev))+ geom_jitter(width = 0.3, shape = 1, size=1.5, alpha = 0.5) Podemos combinar o boxplot com o gráfico de pontos. Nesse caso é necessário retirar os outliers do boxplot pois estão duplicandos os pontos já mostrados. ggplot(field_rs, aes(year, sev))+ geom_boxplot(outlier.shape = NA)+ geom_jitter(width = 0.3, shape = 1, size=1.5, alpha = 0.5) Podemos criar um boxplot condiciondo pelo tipo de resíduo na superfície. ggplot(field_rs, aes(residue, sev, fill = residue))+ geom_boxplot(outlier.shape = NA)+ geom_jitter(width = 0.3, shape = 1, size=1.5, alpha = 0.5) 3.6 Duas variáveis contínuas As variáveis incidência e severidade são ambas de natureza contínua e intrinsecamente relacionadas. A incidência se refere à proporção de espigas doentes. Já a severidade, se refere à proporção de espiguestas doentes em uma amostra de espigas. Ou seja, a espiga é um conjunto de espiguetas. Assim, se espera que em situações com maior proporção de espigas doentes, que surgiram por ocasião de condições favoráveis à doença, também se tenha maior proporção de espiguetas doentes. Vejamos se nossa hipótese é verdadeira. Vamos visualizar a relação entre ambas as variáveis. field_rs %&gt;% filter(residue != &quot;potato&quot;) %&gt;% ggplot(aes(inc, sev))+ geom_point(alpha=0.4)+ theme_grey()+ geom_smooth(method = &quot;loess&quot;, color=&quot;black&quot;, se = F)+ facet_wrap(~ year) Podemos notar que, de maneira geral, há um aumento da severidade com o aumento da incidência, o que dá indícios de que nossa hipótese possa estar correta. Podemos notar também que a relação não é linear. Vamos verificar se essa relação existe independe do ano. ggplot(field_rs, aes(inc, sev))+ geom_point()+ facet_wrap(~ residue) No ano de 2011, os valores de severidade foram mais baixos, embora com alguns casos de incidência mais alta. Biologicamente, isso quer dizer que houve condição para infecção, com descontinuidade de ambiente favorável para o progresso da doença! Já estamos aprendendo algo sobre os dados e sugerindo hipóteses apenas com a visualização apropriada dos dados. Exercícios Faça o gráfico da relação incidência e severidade com cores diferentes dos símbolos para cada ano Verifique se a relação inc e sev muda entre os campos com os diferentes resíduos Podemos verificar se há uma tendência de agregação espacial dos valores de severidade nos diferentes anos. ggplot(field_rs, aes(lat, long))+ geom_point(aes(color = sev), size=2)+ facet_wrap( ~ year, ncol=1)+ scale_colour_gradient(low = &quot;darkgreen&quot;, high =&quot;yellow&quot; ) Uma outra possibilidade é utilizar o tamanho variável do ponto em função da severidade ggplot(field_rs, aes(lat, long))+ geom_point(aes(size = sev), color = &quot;grey&quot;)+ facet_wrap( ~ year, ncol=1) Referências Official ggplot2 tutorial Introduction to R Graphics with ggplot2 R Base Graphics: An Idiot’s Guide Comparing ggplot2 and R Base Graphics Cookbook for R "],
["manipulacao-de-dados-no-r.html", "Capítulo 4 Manipulação de dados no R 4.1 Conjunto de dados 4.2 Selecionando colunas 4.3 Selecionando linhas 4.4 Renomeando variáveis 4.5 Adicionando variáveis 4.6 Removendo variáveis 4.7 Reordenando as linhas 4.8 Encontrar duplicatas 4.9 Renomeando níveis 4.10 Salvando arquivo 4.11 Transposição", " Capítulo 4 Manipulação de dados no R Com os dados carregados no ambiente, seja em vetores, tabelas e data frames (essa a forma mais comum de armazenar os dados), podemos fazer várias operações que envolvem filter, selecionar, rearranjar, renomear, transformar, filtrar, dentre outras ações. 4.1 Conjunto de dados Nesta seção, iremos trabalhar com um conjunto de dados com informações sobre isolados de Fusarium graminearum obtidos de espigas de trigo com sintomas coletadas em visitas à lavouras nos estados do RS e PR. Diversas informações foram obtidas para cada lavoura (local, ano, latitude, longitude, etc), sobre a doença (incidencia e severidade) e da identificação do isolado (espécie e genótipo). Os dados foram informados em uma planilha excel e o arquivo que será trabalho foi nomeado como “survey2.csv”. Vamos carregar esse conjunto de dados no ambiente e atribuir a um data frame survey2. library(readr) survey2 &lt;- read_csv (&quot;data/survey2.csv&quot;) library(dplyr) # A função glimpse é similar à função str do R base glimpse(survey2) # mostra todas as variáveis, uma em cada linha ## Observations: 671 ## Variables: 11 ## $ field &lt;dbl&gt; 25, 25, 25, 25, 25, 26, 26, 26, 26, 36, 48, 49, 49, 4... ## $ year &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010,... ## $ location &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa... ## $ state &lt;chr&gt; &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;,... ## $ lat &lt;dbl&gt; -28.30617, -28.30617, -28.28964, -28.28964, -28.28964... ## $ long &lt;dbl&gt; -52.08281, -52.08281, -51.97308, -51.97308, -51.97308... ## $ residue &lt;chr&gt; &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;... ## $ inc &lt;dbl&gt; 68.24, 68.24, 68.24, 68.24, 68.24, 34.00, 34.00, 34.0... ## $ sev &lt;dbl&gt; 9.47, 9.47, 9.47, 9.47, 9.47, 3.73, 3.73, 3.73, 3.73,... ## $ species &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra... ## $ genotype &lt;chr&gt; &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;... 4.2 Selecionando colunas Eventualmente queremos trabalhar com apenas algumas variáveis, que são armazenadas em um novo data frame. No R base, a seleção pode ser feita por argumentos para seleção de colunas pelo nome das mesmas. Uma possibilidade é criar um vetor “filtro” com o nome das colunas que queremos selecionar e atribuir esse vetor à um novo data frame. # seleciona as três colunas conforme abaixo filtro &lt;- c(&quot;field&quot;, &quot;location&quot;, &quot;species&quot;) # usando os colchetes, seleciona as variáveis do data frame survey2 survey3 &lt;- survey2[filtro] # visualiza o novo data frame glimpse(survey3) ## Observations: 671 ## Variables: 3 ## $ field &lt;dbl&gt; 25, 25, 25, 25, 25, 26, 26, 26, 26, 36, 48, 49, 49, 4... ## $ location &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa... ## $ species &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra... # outra forma seria diretamente pelo número da coluna survey3a &lt;- survey2[c(2:3, 10)] glimpse(survey3a) ## Observations: 671 ## Variables: 3 ## $ year &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010,... ## $ location &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa... ## $ species &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra... No pacote dplyr, a função select permite selecionar as colunas pelo nome. Veja em ?select as várias funções especiais de seleção. survey4 &lt;- select(survey2, year, location, species) survey4 &lt;- select(survey2, c(2:3, 10)) # pelo número das colunas glimpse(survey4) # vai aparecer em um formato mais compacto ## Observations: 671 ## Variables: 3 ## $ year &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010,... ## $ location &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa... ## $ species &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra... A seleção também pode ser feita pela eliminação de algumas variáveis e preservação das demais. Vamos selecionar do data frame survey4 todas as variáveis menos “species”. Para isso, é colocado o sinal de menos na frente da coluna. select(survey4, -species) ## # A tibble: 671 x 2 ## year location ## &lt;dbl&gt; &lt;chr&gt; ## 1 2010 Agua Santa ## 2 2010 Agua Santa ## 3 2010 Agua Santa ## 4 2010 Agua Santa ## 5 2010 Agua Santa ## 6 2010 Agua Santa ## 7 2010 Agua Santa ## 8 2010 Agua Santa ## 9 2010 Agua Santa ## 10 2011 Agua Santa ## # ... with 661 more rows # elimina várias colunas em um intervalo sequencial select(survey2, -c(residue:genotype)) ## # A tibble: 671 x 6 ## field year location state lat long ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 25 2010 Agua Santa RS -28.3 -52.1 ## 2 25 2010 Agua Santa RS -28.3 -52.1 ## 3 25 2010 Agua Santa RS -28.3 -52.0 ## 4 25 2010 Agua Santa RS -28.3 -52.0 ## 5 25 2010 Agua Santa RS -28.3 -52.0 ## 6 26 2010 Agua Santa RS -28.7 -51.2 ## 7 26 2010 Agua Santa RS -28.7 -51.2 ## 8 26 2010 Agua Santa RS -28.7 -51.2 ## 9 26 2010 Agua Santa RS -28.3 -51.5 ## 10 36 2011 Agua Santa RS -28.4 -53.0 ## # ... with 661 more rows 4.3 Selecionando linhas No pacote dplyr a função filter permite selecionar linhas segundo critérios. No data frame survey2 vamos fazer algumas operações para selecionar e contar o número de casos segundo algum critério de filtro. # filtra somente as linhas em que a incidência é maior que 80 filter(survey2, inc &gt; 70) ## # A tibble: 18 x 11 ## field year location state lat long residue inc sev species ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 2010 Carazin~ RS -28.3 -52.7 soybean 72.5 14.3 Fgra ## 2 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 3 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 4 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 5 6 2010 Carazin~ RS -28.3 -51.7 soybean 70.7 8.13 Fasi ## 6 6 2010 Carazin~ RS -28.3 -52.9 soybean 70.7 8.13 Fgra ## 7 6 2010 Carazin~ RS -28.4 -52.9 soybean 70.7 8.13 Fgra ## 8 6 2010 Carazin~ RS -28.4 -52.9 soybean 70.7 8.13 Fgra ## 9 6 2010 Carazin~ RS -28.4 -52.9 soybean 70.7 8.13 Fgra ## 10 13 2009 Condor RS -27.6 -53.3 soybean 70.5 12.8 Fgra ## 11 13 2009 Condor RS -27.6 -53.3 soybean 70.5 12.8 Fgra ## 12 13 2009 Condor RS -27.6 -53.3 soybean 70.5 12.8 Fgra ## 13 13 2009 Condor RS -27.6 -53.3 soybean 70.5 12.8 Fgra ## 14 24 2009 Lageado~ RS -28.1 -52.2 soybean 71 5.22 Fgra ## 15 24 2009 Lageado~ RS -28.1 -52.2 soybean 71 5.22 Fgra ## 16 15 2009 Palmeir~ RS -27.8 -53.4 corn 90.0 18.5 Fgra ## 17 15 2009 Palmeir~ RS -27.8 -53.4 corn 90.0 18.5 Fgra ## 18 15 2009 Palmeir~ RS -27.8 -53.4 corn 90.0 18.5 Fgra ## # ... with 1 more variable: genotype &lt;chr&gt; # retorna o número de casos que atendem ao critério count(filter(survey2, inc &gt; 70)) ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 18 # pode-se criar um dataframe survey_inc75 &lt;- filter(survey2, inc &gt; 75) # múltiplos argumentos de seleção filter(survey2, inc &gt; 50 &amp; sev &gt; 10) ## # A tibble: 24 x 11 ## field year location state lat long residue inc sev species ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 2010 Carazin~ RS -28.3 -52.7 soybean 72.5 14.3 Fgra ## 2 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 3 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 4 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 5 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 6 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 7 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 8 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 9 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 10 13 2009 Condor RS -27.6 -53.3 soybean 70.5 12.8 Fgra ## # ... with 14 more rows, and 1 more variable: genotype &lt;chr&gt; # note abaixo que o sinal de igual é == filter(survey2, location == &quot;Carazinho&quot; &amp; year == &quot;2010&quot;) ## # A tibble: 28 x 11 ## field year location state lat long residue inc sev species ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 2010 Carazin~ RS -28.3 -52.7 soybean 72.5 14.3 Fgra ## 2 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 3 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 4 2 2010 Carazin~ RS -28.3 -52.8 soybean 72.5 14.3 Fgra ## 5 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 6 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 7 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 8 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 9 3 2010 Carazin~ RS -28.3 -52.8 soybean 67 18.6 Fgra ## 10 4 2010 Carazin~ RS -28.3 -51.4 soybean 43.5 17.5 Fcor ## # ... with 18 more rows, and 1 more variable: genotype &lt;chr&gt; 4.4 Renomeando variáveis Conforme já visto, a função fix permite abrir o conjunto em um editor visual para fazer alterações, inclusive modificar o nome das colunas. Vamos traduzir o nome das variáveis no dataframe survey3. colnames(survey3) ## [1] &quot;field&quot; &quot;location&quot; &quot;species&quot; # fix(survey3) glimpse(survey3) ## Observations: 671 ## Variables: 3 ## $ field &lt;dbl&gt; 25, 25, 25, 25, 25, 26, 26, 26, 26, 36, 48, 49, 49, 4... ## $ location &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa... ## $ species &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra... # verifica se o nome foi alterado colnames(survey3) ## [1] &quot;field&quot; &quot;location&quot; &quot;species&quot; No R base, a troca de nomes pode ser feita para todas as variáveis, desde que informadas na mesma sequencia em que se apresentam no data frame. colnames(survey2) ## [1] &quot;field&quot; &quot;year&quot; &quot;location&quot; &quot;state&quot; &quot;lat&quot; &quot;long&quot; ## [7] &quot;residue&quot; &quot;inc&quot; &quot;sev&quot; &quot;species&quot; &quot;genotype&quot; names(survey2) &lt;- c(&quot;campo&quot;,&quot;ano&quot;,&quot;local&quot;, &quot;estado&quot;, &quot;lat&quot;, &quot;long&quot;, &quot;residuo&quot;,&quot;inc&quot;, &quot;sev&quot;, &quot;especie&quot;, &quot;genotipo&quot;) colnames(survey2) ## [1] &quot;campo&quot; &quot;ano&quot; &quot;local&quot; &quot;estado&quot; &quot;lat&quot; &quot;long&quot; ## [7] &quot;residuo&quot; &quot;inc&quot; &quot;sev&quot; &quot;especie&quot; &quot;genotipo&quot; Pode-se também alterar apenas algumas variáveis, usando a função names do R base. names(survey2)[names(survey2)==&quot;inc&quot;] &lt;- &quot;incidencia&quot; names(survey2)[names(survey2)==&quot;sev&quot;] &lt;- &quot;severidade&quot; colnames(survey2) # verifica ## [1] &quot;campo&quot; &quot;ano&quot; &quot;local&quot; &quot;estado&quot; &quot;lat&quot; ## [6] &quot;long&quot; &quot;residuo&quot; &quot;incidencia&quot; &quot;severidade&quot; &quot;especie&quot; ## [11] &quot;genotipo&quot; Alternativamente, no pacote plyr a função rename é mais intuitiva e simples do que a função names. Veja o exemplo abaixo como mudar o nome da variável genotipo para quimiotipo. library(plyr) survey2 &lt;- rename(survey2, c(&quot;genotipo&quot; = &quot;quimiotipo&quot;)) 4.5 Adicionando variáveis No R base, a forma mais rápida de se adicionar uma variável é diretamente no dataframe usando o $ após o nome do data frame. Abaixo, iremos criar uma variável que codifica cada isolado com um número sequencial. # cria o vetor do tamanho do número de linhas (nrow) do dataframe survey2 index &lt;- seq(from = 1, to = nrow(survey2)) head(index, 20) # primeiras 20 linhas ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 tail(index) # últimas 6 linhas ## [1] 666 667 668 669 670 671 # adiciona a variável ao data frame survey2$index &lt;- index colnames(survey2) ## [1] &quot;campo&quot; &quot;ano&quot; &quot;local&quot; &quot;estado&quot; &quot;lat&quot; ## [6] &quot;long&quot; &quot;residuo&quot; &quot;incidencia&quot; &quot;severidade&quot; &quot;especie&quot; ## [11] &quot;quimiotipo&quot; &quot;index&quot; # também poderia ser feito diretamente sem criar o vetor antes survey2$index &lt;- seq(from = 1, to = nrow(survey2)) # pode também ser usado para criar variáveis com transformações # cria nova variável de incidência com nova escala survey2$incidencia2 &lt;- survey2$incidencia/100 Alternativamente, podemos usar a função mutate do pacote dplyr para acrescentar uma ou mais colunas. survey2 &lt;- mutate(survey2, incidencia3 = incidencia2 * 100) head(survey2$incidencia3) ## [1] 68.24 68.24 68.24 68.24 68.24 34.00 4.6 Removendo variáveis No R base, pode-se usar NULL ou subset. Veja os exemplos. # removendo incidencia3 survey2$incidencia3 &lt;- NULL glimpse(survey2) ## Observations: 671 ## Variables: 13 ## $ campo &lt;dbl&gt; 25, 25, 25, 25, 25, 26, 26, 26, 26, 36, 48, 49, 49... ## $ ano &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 20... ## $ local &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Sa... ## $ estado &lt;chr&gt; &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;R... ## $ lat &lt;dbl&gt; -28.30617, -28.30617, -28.28964, -28.28964, -28.28... ## $ long &lt;dbl&gt; -52.08281, -52.08281, -51.97308, -51.97308, -51.97... ## $ residuo &lt;chr&gt; &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybe... ## $ incidencia &lt;dbl&gt; 68.24, 68.24, 68.24, 68.24, 68.24, 34.00, 34.00, 3... ## $ severidade &lt;dbl&gt; 9.47, 9.47, 9.47, 9.47, 9.47, 3.73, 3.73, 3.73, 3.... ## $ especie &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;F... ## $ quimiotipo &lt;chr&gt; &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-AD... ## $ index &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,... ## $ incidencia2 &lt;dbl&gt; 0.6824, 0.6824, 0.6824, 0.6824, 0.6824, 0.3400, 0.... # removendo incidencia2 com a função subset survey2 &lt;- subset(survey2, select = c(-incidencia2)) glimpse(survey2) ## Observations: 671 ## Variables: 12 ## $ campo &lt;dbl&gt; 25, 25, 25, 25, 25, 26, 26, 26, 26, 36, 48, 49, 49,... ## $ ano &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 201... ## $ local &lt;chr&gt; &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua Santa&quot;, &quot;Agua San... ## $ estado &lt;chr&gt; &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS... ## $ lat &lt;dbl&gt; -28.30617, -28.30617, -28.28964, -28.28964, -28.289... ## $ long &lt;dbl&gt; -52.08281, -52.08281, -51.97308, -51.97308, -51.973... ## $ residuo &lt;chr&gt; &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybean&quot;, &quot;soybea... ## $ incidencia &lt;dbl&gt; 68.24, 68.24, 68.24, 68.24, 68.24, 34.00, 34.00, 34... ## $ severidade &lt;dbl&gt; 9.47, 9.47, 9.47, 9.47, 9.47, 3.73, 3.73, 3.73, 3.7... ## $ especie &lt;chr&gt; &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fgra&quot;, &quot;Fg... ## $ quimiotipo &lt;chr&gt; &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADON&quot;, &quot;15-ADO... ## $ index &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ... 4.7 Reordenando as linhas No pacote dplyr, a função arrange pode ser usada para reordenação. # reordena pelo ano survey2 &lt;- arrange(survey2, ano) head(survey2$ano, 20) ## [1] 2009 2009 2009 2009 2009 2009 2009 2009 2009 2009 2009 2009 2009 2009 ## [15] 2009 2009 2009 2009 2009 2009 tail(survey2$ano, 20) ## [1] 2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 ## [15] 2011 2011 2011 2011 2011 2011 # reordena pelo valor de severidade survey2 &lt;- arrange(survey2, severidade) head(survey2$severidade, 20) ## [1] 0.00 0.00 0.00 0.02 0.03 0.03 0.03 0.03 0.03 0.05 0.07 0.07 0.07 0.07 ## [15] 0.09 0.09 0.09 0.09 0.09 0.09 # veja o resultado arrange(survey2, -incidencia) ## # A tibble: 671 x 12 ## campo ano local estado lat long residuo incidencia severidade ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 15 2009 Palm~ RS -27.8 -53.4 corn 90.0 18.5 ## 2 15 2009 Palm~ RS -27.8 -53.4 corn 90.0 18.5 ## 3 15 2009 Palm~ RS -27.8 -53.4 corn 90.0 18.5 ## 4 2 2010 Cara~ RS -28.3 -52.7 soybean 72.5 14.3 ## 5 2 2010 Cara~ RS -28.3 -52.8 soybean 72.5 14.3 ## 6 2 2010 Cara~ RS -28.3 -52.8 soybean 72.5 14.3 ## 7 2 2010 Cara~ RS -28.3 -52.8 soybean 72.5 14.3 ## 8 24 2009 Lage~ RS -28.1 -52.2 soybean 71 5.22 ## 9 24 2009 Lage~ RS -28.1 -52.2 soybean 71 5.22 ## 10 6 2010 Cara~ RS -28.3 -51.7 soybean 70.7 8.13 ## # ... with 661 more rows, and 3 more variables: especie &lt;chr&gt;, ## # quimiotipo &lt;chr&gt;, index &lt;int&gt; 4.8 Encontrar duplicatas Para encontrar registros únicos ou duplicados no data frame usa-se a função unique e duplicate. unique(survey3) # acha linhas únicas ## # A tibble: 213 x 3 ## field location species ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 25 Agua Santa Fgra ## 2 26 Agua Santa Fgra ## 3 26 Agua Santa Fmer ## 4 36 Agua Santa Fgra ## 5 48 Antonio Prado Fcor ## 6 49 Antonio Prado Fgra ## 7 NA Apucarana Fgra ## 8 NA Apucarana Fmer ## 9 NA Arapongas Fgra ## 10 NA Assis Chateaubriand Fmer ## # ... with 203 more rows head(duplicated(survey3), 10) # verifica se é a linha tem dupla entrada ## [1] FALSE TRUE TRUE TRUE TRUE FALSE TRUE TRUE FALSE FALSE # note que aqui é uma função de lógica count(duplicated(survey3)) # conta o número de linhas duplicadas ## x freq ## 1 FALSE 213 ## 2 TRUE 458 4.9 Renomeando níveis Muitas vezes queremos substituir o nome dos níveis de um fator, sem a necessidade de retornar à planilha eletrônica. No exemplo, vamos alterar o nome das espécies que está com a codificação (Fgra, Fmer, etc) para o nome binomial latino. Para isso, vamos usar a função revalue do pacote plyr. survey2$especie &lt;- revalue(survey2$especie, c(&quot;Fgra&quot; = &quot;Fusarium graminearum&quot;)) 4.10 Salvando arquivo Depois de se ter manipulado o conjunto de dados, pode-se salvar o data frame e formato de planilha eletrônica, sendo os mais comuns em formato txt ou csv. No pacote utils do R que é carregado automatica, a função write.csv permite salvar no arquivo externo. # vamos criar o arquivo survey22.csv write.csv(survey2, file = &quot;survey22.csv&quot;) O arquivo csv pode ser aberto em qualquer programa de planilha eletrônica. No entanto, pode-se optar por salvar diretamente no formato xlsx do Excel. Para isso, carrega-se o pacote openxlsx. #library(openxlsx) #write.xlsx(survey2, file = &quot;survey222.xlsx&quot;) 4.11 Transposição Usualmente, várias funções do R seja para estatísticas ou visualização de dados exigem que os dados se apresentem da seguinte forma: cada observação é uma linha e cada coluna é uma variável. É o chamado conjunto na forma “tidy”, ou arrumado, em português. As vezes recebemos dados em que as observações se encontram em várias colunas quando há a interação com outras variáveis. Por exemplo, uma variável é analisada em vários tempos, mas o tempo está como uma variável na coluna e não com uma entrada única para cada tempo. Nesse caso, pode ser necessário fazer a transposição ou “arrumação” do conjunto de colunas para linhas. Vamos usar alguns pacotes do R para fazer essa transposição como o tidy e o reshape2. Vamos trabalhar com o conjunto “ralstonia” do pacote agricolae, o qual contém a contagem de colônias (log(1+UFC/g solo)) em placas de petri. # Carrega o arquivo de dados ralstonia do pacote agricolae library (agricolae) data(ralstonia) # verifica as colunas do conjunto colnames(ralstonia) ## [1] &quot;place&quot; &quot;Day2&quot; &quot;Day15&quot; &quot;Day29&quot; &quot;Day43&quot; &quot;Day58&quot; &quot;Day73&quot; &quot;Day133&quot; head(ralstonia) ## place Day2 Day15 Day29 Day43 Day58 Day73 Day133 ## 1 Namora 7.509 7.552 6.541 6.390 6.214 5.863 4.838 ## 2 Hyo1 7.398 6.720 3.388 1.657 0.000 0.000 0.000 ## 3 Hyo2 7.399 6.118 2.195 0.000 0.000 0.000 0.000 ## 4 SR1 7.418 6.857 6.800 6.508 6.523 6.250 5.451 ## 5 SR2 7.325 7.414 7.221 7.005 6.937 6.777 6.437 ## 6 Cnt1 7.301 7.025 5.992 3.669 2.104 0.000 0.000 No pacote reshape2 vamos utilizar a função melt para fazer a transposição de colunas para linhas. library(reshape2) # usa-se a função melt do pacote reshape2 ralstonia2 &lt;- melt(ralstonia, id=c(&quot;place&quot;), variable.name=&quot;days&quot;, value.name=&quot;count&quot;) No pacote tidyr podemos usar a função gather para o mesmo resultado, porém com muito menos esforço. library(tidyr) ## ## Attaching package: &#39;tidyr&#39; ## The following object is masked from &#39;package:reshape2&#39;: ## ## smiths ralstonia3 &lt;- gather(ralstonia, &quot;day&quot;, &quot;count&quot;, 2:8) Nós podemos fazer o inverso pois, em alguns casos podemos trabalhar com os dados me formatos de uma matriz ou no formato “largo”. A função spread do pacote tidyr facilita essa operação. # usando a função spread do tidyr: mais simples! ralstonia_largo &lt;- spread(ralstonia3, day, count) head(ralstonia_largo) ## place Day133 Day15 Day2 Day29 Day43 Day58 Day73 ## 1 Chmar 5.132 7.552 7.420 6.037 5.835 5.396 5.210 ## 2 Chz 5.037 7.381 7.347 6.856 6.705 6.469 5.959 ## 3 Cnt1 0.000 7.025 7.301 5.992 3.669 2.104 0.000 ## 4 Cnt2 0.000 6.428 7.287 2.195 0.000 0.000 0.000 ## 5 Cnt3 0.000 4.461 7.019 0.000 0.000 0.000 0.000 ## 6 Hco1 5.595 7.703 7.681 7.093 6.974 6.440 6.365 # ou usando a função dcast do reshape2 - mais trabalhoso! ralstonia_largo2 &lt;- dcast(ralstonia3, place ~ day, value.var=&quot;count&quot;) "],
["sumarizacao-dos-dados.html", "Capítulo 5 Sumarização dos dados 5.1 Conjunto de dados 5.2 Dados categóricos 5.3 Dados contínuos", " Capítulo 5 Sumarização dos dados A análise exploratória envolve, além da visualização dos dados, a descrição das variáveis de natureza categórica ou contínuas por meio de algumas métricas específicas, conforme o tipo de variável. No caso de variáveis categóricas, é comum se calcular os totais ou frequencias absolutas ou relativas (percentual) do número de casos em cada nível ou classe das variáveis, quando for o caso. No caso de variáveis contínuas, a sumarização é normalmente feita com base em métricas de estimativas de ponto ou posição (média, mediana, moda, etc) ou de variabilidade/dispersão dos dados (variância, desvio padrão, etc). Veremos a seguir como obter algumas estatísticas sumário, condicionada ou não por níveis de variáveis categóricas, após importar e “arrumar” os dados no R no formato “tidy”. 5.1 Conjunto de dados Continuemos com o conjunto de dados do levantamento de giberela e coleta de isolados do complexo de espécies F. graminearum coletados nos estados do RS e PR, assim como o subconjunto survey_rs, com os dados apenas para o RS. library(readr) survey2 &lt;- read_csv (&quot;data/survey2.csv&quot;) library(dplyr) survey_rs &lt;- filter(survey2, state == &quot;RS&quot;) 5.2 Dados categóricos Para dados categóricos, as funções table e prop.table são muito úteis para sumarizar a frequencia (contagem) de registros. Vamos analisar o conjunto survey2 e contar o número de isolados (cada linha do data frame é um isolado) para uma única variável ou duas variáveis cruzadas, a chamada “tabela de contingência”. # a função attach &quot;libera&quot; as variáveis do data frame attach(survey2) # Número de isolados por ano table(year) ## year ## 2009 2010 2011 ## 270 216 185 # Número de isolados por ano e estado tab &lt;- table (state, year) tab ## year ## state 2009 2010 2011 ## PR 123 0 93 ## RS 147 216 92 str(tab) ## &#39;table&#39; int [1:2, 1:3] 123 147 0 216 93 92 ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ state: chr [1:2] &quot;PR&quot; &quot;RS&quot; ## ..$ year : chr [1:3] &quot;2009&quot; &quot;2010&quot; &quot;2011&quot; # podemos transformar a tabela em um dataframe tab &lt;- table(state, year) data.frame(tab) ## state year Freq ## 1 PR 2009 123 ## 2 RS 2009 147 ## 3 PR 2010 0 ## 4 RS 2010 216 ## 5 PR 2011 93 ## 6 RS 2011 92 # Sumariza os casos em proporção round((prop.table(tab)*100),1) # casos em proporção ## year ## state 2009 2010 2011 ## PR 18.3 0.0 13.9 ## RS 21.9 32.2 13.7 prop.table(tab, 1) # proporção nas linhas ## year ## state 2009 2010 2011 ## PR 0.5694444 0.0000000 0.4305556 ## RS 0.3230769 0.4747253 0.2021978 prop.table(tab, 2) # proporção nas colunas ## year ## state 2009 2010 2011 ## PR 0.4555556 0.0000000 0.5027027 ## RS 0.5444444 1.0000000 0.4972973 # A função margin.table soma apenas na &quot;margem&quot; da tabela ou seja, para cada uma das variáveis. # Soma as frequencias dentro do ano margin.table(table(year,state), 1) ## year ## 2009 2010 2011 ## 270 216 185 # soma as frequencias dentro do estado margin.table(table(year,state), 2) ## state ## PR RS ## 216 455 table(state) ## state ## PR RS ## 216 455 Podemos fazer uma tabela com três entradas incluindo o muncípio de origem do isolado. # continuamos usando a função table. Note que a terceira variável é a que fica em primeiro nível de agrupamento. Depois tem os locais e os anos na coluna tab2 &lt;- table(location, year, state) tab2 ## , , state = PR ## ## year ## location 2009 2010 2011 ## Agua Santa 0 0 0 ## Antonio Prado 0 0 0 ## Apucarana 4 0 0 ## Arapongas 4 0 0 ## Assis Chateaubriand 5 0 0 ## Barreto 0 0 0 ## Bela Vista do Paraiso 1 0 0 ## Boa Vista das Missoes 0 0 0 ## Cambe 4 0 0 ## Campo Mourao 11 0 0 ## Cantagalo 0 0 26 ## Carazinho 0 0 0 ## Cascavel 5 0 0 ## Caseiros 0 0 0 ## Colorado 0 0 0 ## Condor 0 0 0 ## Corbelia 2 0 0 ## Cornelio Procopio 5 0 0 ## Coronel Barros 0 0 0 ## Coxilha 0 0 0 ## Cruz Alta 0 0 0 ## Entre-Ijuis 0 0 0 ## Erechim 0 0 0 ## Ernestina 0 0 0 ## Estacao 0 0 0 ## Farol 2 0 0 ## Formosa do Oeste 4 0 0 ## Ibiaca 0 0 0 ## Ijui 0 0 0 ## Janiopolis 3 0 0 ## Jataizinho 5 0 0 ## Jesuitas 5 0 0 ## Juranda 5 0 0 ## Lageado do Bugre 0 0 0 ## Lagoa Vermelha 0 0 0 ## Mambore 3 0 0 ## Manoel Ribas 0 0 20 ## Marau 0 0 0 ## Maringa 21 0 0 ## Mato Castelhano 0 0 0 ## Nao-me-Toque 0 0 0 ## Palmeira das Missoes 0 0 0 ## Panambi 0 0 0 ## Passo Fundo 0 0 0 ## Pato Branco 6 0 0 ## Peabiru 5 0 0 ## Pejucara 0 0 0 ## Ponta Grossa 6 0 0 ## Rol&lt;U+008A&gt;ndia 1 0 0 ## Roncador 0 0 47 ## Sagrada Familia 0 0 0 ## Sananduva 0 0 0 ## Santa Barbara do Sul 0 0 0 ## Sao Miguel das Missoes 0 0 0 ## Sertaneja 3 0 0 ## Sertanopolis 4 0 0 ## Sertao 0 0 0 ## Soledade 0 0 0 ## Tapejara 0 0 0 ## Tapera 0 0 0 ## Tio Hugo 0 0 0 ## Toledo 5 0 0 ## Tupassi 4 0 0 ## Vacaria 0 0 0 ## Victor Graeff 0 0 0 ## ## , , state = RS ## ## year ## location 2009 2010 2011 ## Agua Santa 0 9 1 ## Antonio Prado 0 5 0 ## Apucarana 0 0 0 ## Arapongas 0 0 0 ## Assis Chateaubriand 0 0 0 ## Barreto 0 4 0 ## Bela Vista do Paraiso 0 0 0 ## Boa Vista das Missoes 7 0 0 ## Cambe 0 0 0 ## Campo Mourao 0 0 0 ## Cantagalo 0 0 0 ## Carazinho 10 28 6 ## Cascavel 0 0 0 ## Caseiros 0 13 0 ## Colorado 0 0 1 ## Condor 8 0 1 ## Corbelia 0 0 0 ## Cornelio Procopio 0 0 0 ## Coronel Barros 7 0 0 ## Coxilha 10 18 0 ## Cruz Alta 11 0 0 ## Entre-Ijuis 4 0 0 ## Erechim 0 9 0 ## Ernestina 7 0 0 ## Estacao 0 5 0 ## Farol 0 0 0 ## Formosa do Oeste 0 0 0 ## Ibiaca 0 5 0 ## Ijui 4 0 25 ## Janiopolis 0 0 0 ## Jataizinho 0 0 0 ## Jesuitas 0 0 0 ## Juranda 0 0 0 ## Lageado do Bugre 4 0 0 ## Lagoa Vermelha 0 25 4 ## Mambore 0 0 0 ## Manoel Ribas 0 0 0 ## Marau 0 0 3 ## Maringa 0 0 0 ## Mato Castelhano 0 5 1 ## Nao-me-Toque 7 0 7 ## Palmeira das Missoes 20 0 1 ## Panambi 8 0 14 ## Passo Fundo 4 15 0 ## Pato Branco 0 0 0 ## Peabiru 0 0 0 ## Pejucara 4 0 0 ## Ponta Grossa 0 0 0 ## Rol&lt;U+008A&gt;ndia 0 0 0 ## Roncador 0 0 0 ## Sagrada Familia 4 0 0 ## Sananduva 0 10 2 ## Santa Barbara do Sul 4 3 6 ## Sao Miguel das Missoes 6 0 0 ## Sertaneja 0 0 0 ## Sertanopolis 0 0 0 ## Sertao 0 13 4 ## Soledade 0 5 0 ## Tapejara 0 18 4 ## Tapera 0 0 2 ## Tio Hugo 4 0 4 ## Toledo 0 0 0 ## Tupassi 0 0 0 ## Vacaria 10 26 4 ## Victor Graeff 4 0 2 prop.table (table(species, residue)) ## residue ## species corn potato soybean ## Fasi 0.000000000 0.000000000 0.006637168 ## Faus 0.004424779 0.000000000 0.002212389 ## Fcor 0.017699115 0.000000000 0.019911504 ## Fgra 0.325221239 0.004424779 0.564159292 ## Fmer 0.026548673 0.000000000 0.028761062 prop.table(table(species, year)) ## year ## species 2009 2010 2011 ## Fasi 0.000000000 0.001490313 0.002980626 ## Faus 0.000000000 0.004470939 0.007451565 ## Fcor 0.004470939 0.017883756 0.002980626 ## Fgra 0.342771982 0.278688525 0.208643815 ## Fmer 0.055141580 0.019374069 0.053651267 table(species, genotype) ## genotype ## species 15-ADON 3-ADON NIV ## Fasi 0 0 3 ## Faus 0 6 2 ## Fcor 0 3 14 ## Fgra 557 0 0 ## Fmer 1 0 85 5.3 Dados contínuos No caso de dados numéricos ou contínuos, o interesse maior é em sumarizar uma série de dados em um único valor, sendo mais comumente usada a média aritmética ou a mediana, dependendo da forma de distribuição dos dados. Essas estimativas podem sem obtidas para um conjunto condicionado ou não por níveis categóricos de uma determinada variável. Na visualização, esse foi o caso visto para o uso de boxplots, histogramas e dotplots. A estatística sumário pode ser calculada condicionada por uma variável categórica que é um tipo de agrupamento. No R podemos usar as funções group_by e summarize para gerar um novo conjunto de dados com os valores sumarizados por determinado grupo. Nesse caso, cada linha do conjunto é o sumário de várias linhas. Primeiramente, vamos eliminar todos as linhas duplicadas de severidade e incidência com o mesmo valor, deixando apenas um valor para cada campo de trigo. Vamos usar a função unique e select. library(dplyr) field_rs &lt;- unique(select(survey_rs, c(1:3,7:9))) # transforma o ano para factor field_rs$year &lt;- as.factor(field_rs$year) Podemos usar a função summary para sumarizar todas as variáveis do conjunto. summary(field_rs) ## field year location residue ## Min. : 1.00 2009:51 Length:137 Length:137 ## 1st Qu.:13.00 2010:49 Class :character Class :character ## Median :25.00 2011:37 Mode :character Mode :character ## Mean :25.41 ## 3rd Qu.:38.00 ## Max. :59.00 ## inc sev ## Min. : 0.00 Min. : 0.000 ## 1st Qu.:11.50 1st Qu.: 0.550 ## Median :25.50 Median : 1.490 ## Mean :29.46 Mean : 2.912 ## 3rd Qu.:44.00 3rd Qu.: 3.730 ## Max. :89.95 Max. :18.650 A função summary pode ser também aplicada somente para uma variável usando o $ após o nome do conjunto. summary(field_rs$sev) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 0.550 1.490 2.912 3.730 18.650 A função describe do pacote Hmisc oferece uma opção de sumarização. library(Hmisc) describe(field_rs$sev) ## field_rs$sev ## n missing distinct Info Mean Gmd .05 .10 ## 137 0 122 1 2.912 3.441 0.090 0.236 ## .25 .50 .75 .90 .95 ## 0.550 1.490 3.730 7.464 10.138 ## ## lowest : 0.00 0.02 0.03 0.05 0.07, highest: 14.10 14.27 17.48 18.51 18.65 Pode-se usar essas funções individualmente como nos exemplos abaixo. Note que, até agora, a estatística foi obtida para todos os valores da variável, sem qualquer agrupamento. mean(field_rs$sev) ## [1] 2.912482 median(field_rs$sev) ## [1] 1.49 IQR(field_rs$sev) ## [1] 3.18 sd(field_rs$sev) ## [1] 3.719815 Agora iremos obter a estatística sumário por grupos ou níveis de uma variável categórica. Para isso, utilizaremos a função group_by e summarize do pacote dplyr. # Agrupamento por ano library(dplyr) by_year &lt;- group_by(field_rs, year) head(by_year) ## # A tibble: 6 x 6 ## # Groups: year [2] ## field year location residue inc sev ## &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 25 2010 Agua Santa soybean 68.2 9.47 ## 2 26 2010 Agua Santa corn 34 3.73 ## 3 36 2011 Agua Santa soybean 40.5 1.31 ## 4 48 2010 Antonio Prado soybean 2 0.02 ## 5 49 2010 Antonio Prado corn 11 0.22 ## 6 38 2010 Barreto soybean 13 0.46 str(by_year) ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 137 obs. of 6 variables: ## $ field : num 25 26 36 48 49 38 21 22 2 3 ... ## $ year : Factor w/ 3 levels &quot;2009&quot;,&quot;2010&quot;,..: 2 2 3 2 2 2 1 1 2 2 ... ## $ location: chr &quot;Agua Santa&quot; &quot;Agua Santa&quot; &quot;Agua Santa&quot; &quot;Antonio Prado&quot; ... ## $ residue : chr &quot;soybean&quot; &quot;corn&quot; &quot;soybean&quot; &quot;soybean&quot; ... ## $ inc : num 68.2 34 40.5 2 11 ... ## $ sev : num 9.47 3.73 1.31 0.02 0.22 ... ## - attr(*, &quot;vars&quot;)= chr &quot;year&quot; ## - attr(*, &quot;drop&quot;)= logi TRUE ## - attr(*, &quot;indices&quot;)=List of 3 ## ..$ : int 6 7 16 18 19 24 25 27 28 29 ... ## ..$ : int 0 1 3 4 5 8 9 10 11 12 ... ## ..$ : int 2 14 15 17 23 26 50 51 52 53 ... ## - attr(*, &quot;group_sizes&quot;)= int 51 49 37 ## - attr(*, &quot;biggest_group_size&quot;)= int 51 ## - attr(*, &quot;labels&quot;)=&#39;data.frame&#39;: 3 obs. of 1 variable: ## ..$ year: Factor w/ 3 levels &quot;2009&quot;,&quot;2010&quot;,..: 1 2 3 ## ..- attr(*, &quot;vars&quot;)= chr &quot;year&quot; ## ..- attr(*, &quot;drop&quot;)= logi TRUE str(field_rs) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 137 obs. of 6 variables: ## $ field : num 25 26 36 48 49 38 21 22 2 3 ... ## $ year : Factor w/ 3 levels &quot;2009&quot;,&quot;2010&quot;,..: 2 2 3 2 2 2 1 1 2 2 ... ## $ location: chr &quot;Agua Santa&quot; &quot;Agua Santa&quot; &quot;Agua Santa&quot; &quot;Antonio Prado&quot; ... ## $ residue : chr &quot;soybean&quot; &quot;corn&quot; &quot;soybean&quot; &quot;soybean&quot; ... ## $ inc : num 68.2 34 40.5 2 11 ... ## $ sev : num 9.47 3.73 1.31 0.02 0.22 ... Na sequencia, usaremos a função summarize para criar um novo conjunto de dados com o nome “dis_by_year2” onde cada linha conterá o valor da estatística. No exemplo, será calculada a média de severidade e incidência em cada grupo criado no conjunto by_year2. dis_by_year2 &lt;- summarise(group_by(survey_rs, year), inc_mean = mean(inc), inc_sd = sd(inc), sev_mean = mean(sev), sev_sd = sd(sev), n_fields = length(sev) ) dis_by_year2 ## inc_mean inc_sd sev_mean sev_sd n_fields ## 1 30.57743 20.74751 3.172923 4.012563 455 "],
["delineamentos-experimentais.html", "Capítulo 6 Delineamentos experimentais 6.1 Experimento simples 6.2 Experimento fatorial", " Capítulo 6 Delineamentos experimentais Experimentos podem ser planejados em diferentes esquemas ou arranjos e delineamentos (design). Delineamento é a forma de distribuição ou aleatorização dos tratamentos na área experimental. Os principais delineamentos experimentais utilizados são: inteiramente casualizado, blocos casualizados e quadrado latino. Já o esquema (ou arranjo) é a forma que dois ou mais fatores, estudados ao mesmo temo, sendo os principais o fatorial, parcela subdividida e experimentos em faixa. Os arranjos e delineamentos mais comumente utilizados em experimentos de fitopatologia são: Inteiramente casualizado (CRD) Blocos casualizados (RCBD) Parcelas subdivididas (split-plot) Em quaisquer dos casos, a alocação dos tratamentos nas unidades experimentais deve ser feita de maneira aleatória, segundo o princípio da casualização. Em experimentos com controle local, os tratamentos são aleatorizados dentro de cada bloco. No R, o pacote agricolae tem algumas funções que permitem ao pesquisador gerar delineamentos específicos. Nas páginas de help do pacote agricolae, existem algumas funções design para vários tipos de delineamentos. Na sequência, serão demonstrados os delineamentos principais com base em exemplos da literatura fitopatológica. 6.1 Experimento simples 6.1.1 Inteiramente casualizado Indicado quando há baixa ou nenhuma variabilidade entre as parcelas experimentais, assim as condições experimentais são bem controladas. Indicado para experimentos de laboratórios, câmra climatizada, casa de vegetação, ou mesmo em campo onde há pouca heterogeneidade na área. A vantagem é que um delinamento mais simples de instalar e conduzir, além de ter o maior número de graus de liberdade. Nome da função : ?design.crd Exercício Gerar um delineamento para um experimento em ambiente controlado com objetivo de para verificar o efeito de duas doses de Mg no desenvolvimento da escaldadura do arroz. Two experiments (Experiments 1 and 2), consisting of two treatments (hereafter referred to as 0.5 and 1.5 mM Mg) and arranged in a completely randomized design with eight replications, were performed to determine the foliar Mg concentration and the length of the leaf scald lesions. Fonte Tatagiba and Rodrigues (2016). library (agricolae)# carrega o pacote no ambiente dose &lt;- c(&quot;dose_0.5&quot;, &quot;dose_1.5&quot;) # níveis do fator r &lt;- 8 # número de repetições crd1 &lt;- design.crd(dose, r, serie = 2, 2543) Cria uma matriz para visualizar a alocação física dos tratamentos de acordo com o espaço disponível. str(crd1) # verifica a estrutura do objeto ## List of 2 ## $ parameters:List of 7 ## ..$ design: chr &quot;crd&quot; ## ..$ trt : chr [1:2] &quot;dose_0.5&quot; &quot;dose_1.5&quot; ## ..$ r : num [1:2] 8 8 ## ..$ serie : num 2 ## ..$ seed : num 2543 ## ..$ kinds : chr &quot;Super-Duper&quot; ## ..$ : logi TRUE ## $ book :&#39;data.frame&#39;: 16 obs. of 3 variables: ## ..$ plots: num [1:16] 101 102 103 104 105 106 107 108 109 110 ... ## ..$ r : int [1:16] 1 2 3 4 1 2 3 4 5 5 ... ## ..$ dose : Factor w/ 2 levels &quot;dose_0.5&quot;,&quot;dose_1.5&quot;: 2 2 2 2 1 1 1 1 1 2 ... Note acima que o objeto é uma lista. Agora vamos gerar uma matriz da ordem de alocações dos tratamentos com quatro colunas. Primeiro vamos extrair as informações sobre o código das parcelas, a repetição e o tratamento de nível de magnésio e atribuir em m1. Depois, com a função interaction criaremos uma nova codificação mais intuitiva da repetição do tratamento. m1 &lt;- data.frame(crd1$book$plots, crd1$book$dose, crd1$book$r) colnames (m1) &lt;- c(&quot;code&quot;, &quot;Mg&quot;, &quot;rep&quot;) # muda o nome das variáveis # cria um código para a combinação repetição e tratamento # especifica o separador que vai indicar o número da repetição m1$trat &lt;- interaction (m1$Mg, m1$rep, sep = &quot;_rep&quot;) matrix (m1$trat, ncol = 4) # função para gerar matriz ## [,1] [,2] [,3] [,4] ## [1,] &quot;dose_1.5_rep1&quot; &quot;dose_0.5_rep1&quot; &quot;dose_0.5_rep5&quot; &quot;dose_0.5_rep7&quot; ## [2,] &quot;dose_1.5_rep2&quot; &quot;dose_0.5_rep2&quot; &quot;dose_1.5_rep5&quot; &quot;dose_1.5_rep7&quot; ## [3,] &quot;dose_1.5_rep3&quot; &quot;dose_0.5_rep3&quot; &quot;dose_0.5_rep6&quot; &quot;dose_0.5_rep8&quot; ## [4,] &quot;dose_1.5_rep4&quot; &quot;dose_0.5_rep4&quot; &quot;dose_1.5_rep6&quot; &quot;dose_1.5_rep8&quot; Acima, a matriz de disposição dos tratamentos com a indicação dos códigos dos tratamento e sua respectiva repetição. 6.1.2 Blocos casualizados Indicado para situações em que as condições experimentais não são homogêneas. Assim, a área heterogênea é dividida em blocos com maior homogeneidade possível. A vantagem é justamente controlar as diferenças entre os blocos, levando assim a uma estimativa mais exata variância residual. As desvantagens incluem menor número de graus de liberdade. No pacote agricolae o nome da função é design.rcbd. Exercício Gera um delineamento para o experimento conforme descrição abaixo Randomized complete block design experiments with two cultivation systems (conventional and no-tillage) and four replications were carried out during the 1997/2003 growing seasons at Campo Mourão, PR, Brazil. The plot size was 11 m×3.5 m with seven rows of soybean cv. BR-16 (0.5 m inter-rows) with a final density of 16 plants per linear meter. Almeida et al., (2015) tillage &lt;- c(&quot;conventional&quot;, &quot;no-tillage&quot;) rcbd1 &lt;- design.rcbd(tillage, 4, serie = 0, 1000, &quot;Wichmann-Hill&quot;) 6.2 Experimento fatorial 6.2.1 Inteiramente casualizado Nesse caso, a alocação das repetições dos tratamentos que resultam da interação entre dois fatores é feita de maneira aleatória, sem controle local. O nome da função no agricolae é design.ab. Exercício Gera um delineamento segundo a descrição abaixo. Two 2 × 4 factorial experiments consisting of two cultivars (BR-18 and BRS-229) and the inducers (ASM, AJ and ET) plus distilled water (control treatment) were arranged in a completely randomized design, with four replications. Each experimental unit consisted of one plastic container with two plants. Fonte: Rios et al. (2014) . Passos da análise Gera a ordem de alocação dos tratamentos Cria um data.frame com cultivar, inducer e repetição extraído da lista Cria um vetor com a interaçao para criar um código interpretável da parcela Gera uma matrix com 3 colunas, uma para cada linha na bancada de uma casa de vegetação Transforma de matrix para data.frame Muda o nome das colunas para “linha 1”, “linha 2”, etc. # 2 cultivares e três indutores e quatro repetições trt &lt;- c(2,3) fat1 &lt;- design.ab(trt, r = 4, design = &quot;crd&quot;, serie = 1) dat1 &lt;- data.frame(fat1$book$plots, fat1$book$A, fat1$book$B, fat1$book$r) dat1$plot2 &lt;- interaction(dat1[ ,2:4], sep = &quot;_&quot;) m1 &lt;- matrix(dat1$plot2, ncol=3) m2 &lt;- as.data.frame(m1) colnames(m2) &lt;- c(&quot;linha 1&quot;, &quot;linha 2&quot;, &quot;linha 3&quot;) m2 ## linha 1 linha 2 linha 3 ## 1 2_3_1 1_2_3 2_1_3 ## 2 2_2_1 1_3_3 2_1_4 ## 3 1_1_1 2_1_1 2_2_2 ## 4 1_3_1 2_1_2 2_2_3 ## 5 2_3_2 1_1_2 1_3_4 ## 6 1_2_1 1_1_3 1_2_4 ## 7 1_3_2 2_3_3 2_2_4 ## 8 1_2_2 2_3_4 1_1_4 6.2.2 Parcela dividida Delineamentos em parcelas subdivididas tem um arranjo do tipo fatorial pois um segundo fator, normalmente em menor número de níveis, é aleatorizado na mesma parcela de um fator principal. Sua vantagem é a diminuição do número de parcelas. No agricolae o nome da função é design.split. Exercício Experimento de campo para testar o efeito da interação híbridos de milho de método de inoculação. Trials were arranged in a 14 × 2 factorial experiment in a split-plot design with four replications. Hybrids (0F53HX, 30F53YH, 30K64HNSR, 30S31H, 30S31YH, BG7049H, Dow2B707, P1630H, P30F53YH, P30S31HR, P32R48H, P3646H, STATUS VIP and, STATUS VIP3) were randomly assigned to the main plots, which consisted of four rows. Plots were split into two sub-plots that were randomly assigned to either the silk channel or the pin inoculation treatment. Fonte: Nerbass et al. (2015) # parcela principal hybrids &lt;- c(&quot;0F53HX&quot;, &quot;30F53YH&quot;, &quot;30K64HNSR&quot;,&quot;30S31H&quot;, &quot;30S31YH&quot;, &quot;BG7049H&quot;, &quot;Dow2B707&quot;, &quot;P1630H&quot;, &quot;P30F53YH&quot;, &quot;P30S31HR&quot;, &quot;P32R48H&quot;, &quot;P3646H&quot;, &quot;STATUS VIP&quot;, &quot;STATUS VIP3&quot;) #subparcela inoculation &lt;- c(&quot;silk&quot;, &quot;pin&quot;) sp1 &lt;- design.split(hybrids, inoculation, design=&quot;crd&quot;, r = 4, serie = 0) head(sp1$book, 10) # mostra 10 primeiras parcelas ## plots splots r hybrids inoculation ## 1 1 1 1 30K64HNSR silk ## 2 1 2 1 30K64HNSR pin ## 3 2 1 1 P3646H silk ## 4 2 2 1 P3646H pin ## 5 3 1 1 30S31H silk ## 6 3 2 1 30S31H pin ## 7 4 1 1 P32R48H pin ## 8 4 2 1 P32R48H silk ## 9 5 1 1 STATUS VIP3 silk ## 10 5 2 1 STATUS VIP3 pin Note abaixo que o delineamento escolhido foi inteiramente casualizado, onde a repetição de cada híbrido é sorteado em qualquer parcela da área experimental. 6.2.3 Blocos casualizados No exemplo anterior, onde apenas o fator manejo do solo (conventional or non-tillage) havia sido testado, adiciona um novo fator, cultivar, com 5 níveis e refaz o delineamento agora em blocos casualizados completos. trt&lt;-c(2,5) # fatorial 2 A = 2 níveis de manejo e B = 5 cultivares rcbd2 &lt;- design.ab(trt, r = 4, design = &quot;rcbd&quot;, serie = 2) head(rcbd2$book, 15) ## plots block A B ## 1 101 1 2 5 ## 2 102 1 2 2 ## 3 103 1 1 3 ## 4 104 1 2 1 ## 5 105 1 1 4 ## 6 106 1 1 5 ## 7 107 1 1 1 ## 8 108 1 2 3 ## 9 109 1 1 2 ## 10 110 1 2 4 ## 11 111 2 2 5 ## 12 112 2 1 4 ## 13 113 2 2 1 ## 14 114 2 2 2 ## 15 115 2 1 1 # A diferença foi o atributo design rcbd "]
]
